#!/bin/bash

#
# Copyright (c) 2006 Mellanox Technologies. All rights reserved.
#
# This Software is licensed under one of the following licenses:
#
# 1) under the terms of the "Common Public License 1.0" a copy of which is
#    available from the Open Source Initiative, see
#    http://www.opensource.org/licenses/cpl.php.
#
# 2) under the terms of the "The BSD License" a copy of which is
#    available from the Open Source Initiative, see
#    http://www.opensource.org/licenses/bsd-license.php.
#
# 3) under the terms of the "GNU General Public License (GPL) Version 2" a
#    copy of which is available from the Open Source Initiative, see
#    http://www.opensource.org/licenses/gpl-license.php.
#
# Licensee has the right to choose one of the above licenses.
#
# Redistributions of source code must retain the above copyright
# notice and one of the license notices.
#
# Redistributions in binary form must reproduce both the above copyright
# notice, one of the license notices in the documentation
# and/or other materials provided with the distribution.
#
#
# processname: /usr/sbin/opensm
# config: /etc/opensm.conf
# pidfile: /var/run/opensm.pid

if [ ! -f /etc/opensm.conf ]; then
    exit 0
fi

. /etc/opensm.conf

CONFIG=/etc/opensm.conf

prog=/usr/sbin/opensm
bin=${prog##*/}

# Handover daemon for updating guid2lid cache file
sldd_prog=/usr/sbin/sldd.sh
sldd_bin=${sldd_prog##*/}
sldd_pid_file=/var/run/sldd.pid

# Only use ONBOOT option if called by a runlevel directory.
# Therefore determine the base, follow a runlevel link name ...
base=${0##*/}
link=${base#*[SK][0-9][0-9]}
# ... and compare them
if [ $link == $base ] ; then
    ONBOOT=yes
fi

ACTION=$1
shift

if [ ! -x  $prog ]; then
    echo "OpenSM not installed"
    exit 1
fi

# Check if OpenSM configured to start automatically
if [[ -z $ONBOOT || "$ONBOOT" != "yes" ]]; then
    exit 0
fi

if ( grep -i 'SuSE Linux' /etc/issue >/dev/null 2>&1 ); then
    if [ -n "$INIT_VERSION" ] ; then
        # MODE=onboot
        if LANG=C egrep -L "^ONBOOT=['\"]?[Nn][Oo]['\"]?" ${CONFIG} > /dev/null ; then
            exit 0
        fi
    fi
fi

if [ -f /etc/init.d/functions ]; then
    . /etc/init.d/functions
fi

# Setting OpenSM start parameters
PID_FILE=/var/run/${bin}.pid
touch $PID_FILE

if [[ -z $DEBUG || "$DEBUG" == "none" ]]; then
    DEBUG_FLAG=""
else
    DEBUG_FLAG="-d ${DEBUG}"
fi

if [[ -z $LMC || "$LMC" == "0" ]]; then
    LMC_FLAG=""
else
    LMC_FLAG="-l ${LMC}"
fi

if [[ -z $MAXSMPS || "$MAXSMPS" == "4" ]]; then
    MAXSMPS_FLAG=""
else
    MAXSMPS_FLAG="-maxsmps ${MAXSMPS}"
fi

if [[ -z $REASSIGN_LIDS || "$REASSIGN_LIDS" == "no" ]]; then
    REASSIGN_LIDS_FLAG=""
else
    REASSIGN_LIDS_FLAG="-r"
fi

if [[ -z $SWEEP || "$SWEEP" == "10" ]]; then
    SWEEP_FLAG=""
else
    SWEEP_FLAG="-s ${SWEEP}"
fi

if [[ -z $TIMEOUT || "$TIMEOUT" == "100" ]]; then
    TIMEOUT_FLAG=""
else
    TIMEOUT_FLAG="-t ${TIMEOUT}"
fi

if [[ -z $OSM_LOG || "$OSM_LOG" == "/var/log/osm.log" ]]; then
    OSM_LOG_FLAG=""
else
    OSM_LOG_FLAG="-f ${OSM_LOG}"
fi

if [[ -z $VERBOSE || "$VERBOSE" == "none" ]]; then
    VERBOSE_FLAG=""
else
    VERBOSE_FLAG="${VERBOSE}"
fi

if [[ -z $UPDN || "$UPDN" == "off" ]]; then
    UPDN_FLAG=""
else
    UPDN_FLAG="-u"
fi

if [[ -z $GUID_FILE || "$GUID_FILE" == "none" ]]; then
    GUID_FILE_FLAG=""
else
    GUID_FILE_FLAG="-a ${GUID_FILE}"
fi

if [[ -z $GUID || "$GUID" == "none" ]]; then
    GUID_FLAG=""
else
    GUID_FLAG="-g ${GUID}"
fi

if [[ -z $HONORE_GUID2LID || "$HONORE_GUID2LID" == "none" ]]; then
    HONORE_GUID2LID_FLAG=""
else
    HONORE_GUID2LID_FLAG="--honor_guid2lid"
fi

if [[ -n "${OSM_HOSTS}" && $(echo -n ${OSM_HOSTS} | wc -w | tr -d '[:space:]') -gt 1  ]]; then
    HONORE_GUID2LID_FLAG="--honor_guid2lid"
fi


if [[ -z $CACHE_OPTIONS || "$CACHE_OPTIONS" == "none" ]]; then
    CACHE_OPTIONS_FLAG=""
else
    CACHE_OPTIONS_FLAG="--cache-options"
fi


if [ -z $PORT_NUM ]; then
    PORT_FLAG=1
else
    PORT_FLAG="${PORT_NUM}"
fi


#########################################################################
# Get a sane screen width
[ -z "${COLUMNS:-}" ] && COLUMNS=80

[ -z "${CONSOLETYPE:-}" ] && [ -x /sbin/consoletype ] && CONSOLETYPE="`/sbin/consoletype`"

if [ -f /etc/sysconfig/i18n -a -z "${NOLOCALE:-}" ] ; then
  . /etc/sysconfig/i18n
  if [ "$CONSOLETYPE" != "pty" ]; then
        case "${LANG:-}" in
                ja_JP*|ko_KR*|zh_CN*|zh_TW*)
                        export LC_MESSAGES=en_US
                        ;;
                *)
                        export LANG
                        ;;
        esac
  else
        export LANG
  fi
fi

# Read in our configuration
if [ -z "${BOOTUP:-}" ]; then
  if [ -f /etc/sysconfig/init ]; then
      . /etc/sysconfig/init
  else
    # This all seem confusing? Look in /etc/sysconfig/init,
    # or in /usr/doc/initscripts-*/sysconfig.txt
    BOOTUP=color
    RES_COL=60
    MOVE_TO_COL="echo -en \\033[${RES_COL}G"
    SETCOLOR_SUCCESS="echo -en \\033[1;32m"
    SETCOLOR_FAILURE="echo -en \\033[1;31m"
    SETCOLOR_WARNING="echo -en \\033[1;33m"
    SETCOLOR_NORMAL="echo -en \\033[0;39m"
    LOGLEVEL=1
  fi
  if [ "$CONSOLETYPE" = "serial" ]; then
      BOOTUP=serial
      MOVE_TO_COL=
      SETCOLOR_SUCCESS=
      SETCOLOR_FAILURE=
      SETCOLOR_WARNING=
      SETCOLOR_NORMAL=
  fi
fi

if [ "${BOOTUP:-}" != "verbose" ]; then
   INITLOG_ARGS="-q"
else
   INITLOG_ARGS=
fi

echo_success() {
  echo -n $@
  [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
  echo -n "[  "
  [ "$BOOTUP" = "color" ] && $SETCOLOR_SUCCESS
  echo -n $"OK"
  [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
  echo -n "  ]"
  echo -e "\r"
  return 0
}

echo_failure() {
  echo -n $@
  [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
  echo -n "["
  [ "$BOOTUP" = "color" ] && $SETCOLOR_FAILURE
  echo -n $"FAILED"
  [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
  echo -n "]"
  echo -e "\r"
  return 1
}


#########################################################################

# Check if $pid (could be plural) are running
checkpid() {
        local i

        for i in $* ; do
                [ -d "/proc/$i" ] || return 1
        done
        return 0
}

start_sldd()
{
    if [ -f $sldd_pid_file ]; then
            local line p
            read line < $sldd_pid_file
            for p in $line ; do
                    [ -z "${p//[0-9]/}" -a -d "/proc/$p" ] && sldd_pid="$sldd_pid $p"
            done
    fi

    if [ -z "$sldd_pid" ]; then
        sldd_pid=`pidof -x $sldd_bin`
    fi

    if [ -n "${sldd_pid:-}" ] ; then
	kill -9 ${sldd_pid} > /dev/null 2>&1
    fi

    $sldd_prog > /dev/null 2>&1 &
    sldd_pid=$!

    echo ${sldd_pid} > $sldd_pid_file
    # Sleep is needed in order to update local gid2lid cache file before running opensm
    sleep 3
}

stop_sldd()
{
    if [ -f $sldd_pid_file ]; then
            local line p
            read line < $sldd_pid_file
            for p in $line ; do
                    [ -z "${p//[0-9]/}" -a -d "/proc/$p" ] && sldd_pid="$sldd_pid $p"
            done
    fi

    if [ -z "$sldd_pid" ]; then
        sldd_pid=`pidof -x $sldd_bin`
    fi

    if [ -n "${sldd_pid:-}" ] ; then
        kill -15 ${sldd_pid} > /dev/null 2>&1
    fi

}

start()
{
    if [ ! -d /sys/class/infiniband ]; then
        echo
        echo "Please load Infiniband driver first"
        echo
        return 2
    fi

    local OSM_PID=

    if [ -f $PID_FILE ]; then
            local line p
            read line < $PID_FILE
            for p in $line ; do
                    [ -z "${p//[0-9]/}" -a -d "/proc/$p" ] && pid="$pid $p"
            done
    fi

    if [ -z "$pid" ]; then
        pid=`pidof -o $$ -o $PPID -o %PPID -x $bin`
    fi

    if [ -n "${pid:-}" ] ; then
        echo $"${bin} (pid $pid) is already running..."
    else

	if [ -n "${HONORE_GUID2LID_FLAG}" ]; then
		# Run sldd daemod
		start_sldd
	fi

        # Start opensm
        local START_FLAGS=""
        for flag in "$DEBUG_FLAG" "$LMC_FLAG" "$MAXSMPS_FLAG" "$REASSIGN_LIDS_FLAG" "$SWEEP_FLAG" "$TIMEOUT_FLAG" "$OSM_LOG_FLAG" "$VERBOSE_FLAG" "$UPDN_FLAG" "$GUID_FILE_FLAG" "$GUID_FLAG" "$HONORE_GUID2LID_FLAG" "$CACHE_OPTIONS_FLAG"
        do
            [ ! -z "$flag" ] && START_FLAGS="$START_FLAGS $flag"
        done

        echo $PORT_FLAG | $prog $START_FLAGS > /dev/null 2>&1 &
        OSM_PID=$!
        echo $OSM_PID > $PID_FILE
	sleep 1
        checkpid $OSM_PID
        RC=$?
        [ $RC -eq 0 ] && echo_success "$bin start" || echo_failure "$bin start"

    fi
return $RC
}

stop()
{
    local pid=
    local pid1=
    local pid2=

    # Stop sldd daemon
    stop_sldd

    if [ -f $PID_FILE ]; then
            local line p
            read line < $PID_FILE
            for p in $line ; do
                    [ -z "${p//[0-9]/}" -a -d "/proc/$p" ] && pid1="$pid1 $p"
            done
    fi

    pid2=`pidof -o $$ -o $PPID -o %PPID -x $bin`

    pid=`echo "$pid1 $pid2" | sed -e 's/\ /\n/g' | sort -n | uniq | sed -e 's/\n/\ /g'`

    if [ -n "${pid:-}" ] ; then
        # Kill opensm
        kill -15 $pid > /dev/null 2>&1
		cnt=0
        while [ $cnt -lt 6 ]; do echo -n "."; sleep 1; let cnt++;done

        for p in $pid
        do
            while checkpid $p ; do
                kill -KILL $p > /dev/null 2>&1
                echo -n "."
                sleep 1
            done
        done
        echo
        checkpid $pid
        RC=$?
        [ $RC -eq 0 ] && echo_failure "$bin shutdown" || echo_success "$bin shutdown"
        RC=$((! $RC))
    else
        echo_failure "$bin shutdown"
        RC=1
    fi

    # Remove pid file if any.
    rm -f $PID_FILE
return $RC
}

status()
{
    local pid

    # First try "pidof"
    pid=`pidof -o $$ -o $PPID -o %PPID -x ${bin}`
    if [ -n "$pid" ]; then
            echo $"${bin} (pid $pid) is running..."
            return 0
    fi

     # Next try "/var/run/opensm.pid" files
     if [ -f $PID_FILE ] ; then
             read pid < $PID_FILE
             if [ -n "$pid" ]; then
                     echo $"${bin} dead but pid file $PID_FILE exists"
                     return 1
             fi
     fi
     echo $"${bin} is stopped"
     return 3
}



case $ACTION in
	start)
                start
		;;
	stop)
		stop
		;;
	restart)
		stop
                start
		;;
	status)
		status
		;;
	*)
		echo
		echo "Usage: `basename $0` {start|stop|restart|status}"
		echo
		exit 1
		;;
esac

RC=$?
exit $RC
